Writing the Third Edition
The exam for the Sun Certified Programmer for Java Platform, Standard Edition 6,
has changed considerably since the second edition of this book was published. The
most noticeable change in the current version of the Sun Certified Java Programmer (SCJP) 1.6 exam is the inclusion of the features of Java 5, and the shifting of
emphasis towards analyzing code scenarios, rather than individual language constructs. In our opinion, the new exam demands an even greater understanding and
actual experience of the language, rather than mere recitation of facts. Proficiency
in the language is the key to success.
Since the emphasis of the SCJP 1.6 exam is on the core features of Java, the third
edition provides even greater in-depth coverage of the relevant topics. The book
covers not just the exam objectives, but also supplementary topics that aid in mastering the exam topics.
The third edition is still a one-source guide for the SCJP 1.6 exam: it provides a mixture of theory and practice for the exam. Use the book to learn Java, pass the SCJP
1.6 exam, and afterwards, use it as a handy language guide. The book also has an
appendix devoted to the SCJP 1.6 Upgrade exam.
We have taken into consideration the feedback we have received from readers. The
many hours spent in handling the deluge of e-mail have not been in vain. Every
single e-mail is appreciated and is hereby acknowledged.
Preparing the third edition dispelled our illusions about newer editions being, to
put it colloquially, a piece of cake. Every sentence from the second edition has been
weighed carefully, and not many paragraphs have escaped rewriting. UML (Unified Modeling Language) is also extensively employed in this edition. Numerous
new review questions have been added. In covering the new topics and expanding
the existing ones, new examples, figures, and tables were also specifically created
for the third edition
About This Book
This book provides extensive coverage of the Java programming language and its
core Application Programming Interfaces (APIs), with particular emphasis on its
syntax and usage. The book is primarily intended for professionals who want to
prepare for the SCJP 1.6 exam, but it is readily accessible to any programmer who
wants to master the language. For both purposes, it provides in-depth coverage of
essential features of the language and its core APIs.
There is a great and increasing demand for certified Java programmers. Sun
Microsystems has defined the SCJP 1.6 exam as one that professionals can take to
validate their skills. The certification provides the IT industry with a standard to
use for hiring such professionals, and allows the professionals to turn their Java
skills into credentials that are important for career advancement.
The book provides extensive coverage of all the objectives defined for the exam by
Sun. But the exam objectives are selective and do not include many of the essential
features of Java. This book covers many additional topics that every Java programmer should master in order to be proficient. In this regard, the book is a comprehensive primer for learning the Java programming language. After mastering the
language by working through this book, the reader can confidently sit for the
exam.
This book is not a complete reference for Java, as it does not attempt to list every
member of every class from the Java Development Kit (JDK) API documentation.
The purpose is not to document the JDK APIs. This book does not teach
programming techniques. The emphasis is on the Java programming language
features, their syntax and correct usage through code examples.
The book assumes little background in programming. We believe the exam is
accessible to any programmer who works through the book. A Java programmer
can easily skip over material that is well understood and concentrate on parts that
need reinforcing, whereas a programmer new to Java will find the concepts
explained from basic principles. 
Each topic is explained and discussed thoroughly with examples, and backed by
review questions and exercises to reinforce the concepts. The book is not biased
toward any particular platform, but provides platform-specific details where
necessary.
Using the Book
The reader can choose a linear or a non-linear route through the book, depending
on her programming background. Non-Java programmers wishing to migrate to
Java can read Chapter 1, which provides a short introduction to object-oriented
programming concepts, and the procedure for compiling and running Java appli-
PREFACE xxxix
cations. For those preparing for the SCJP 1.6 exam, the book has a separate appendix providing all the pertinent information on taking the exam.
The table of contents; listings of tables, examples, and figures; and a comprehensive index facilitate locating topics discussed in the book.
In particular, we draw attention to the following features:
Review Questions
Review questions are provided after every major topic, in order to test and reinforce the material. These review questions reflect the kinds of questions that can be
asked on the actual exam. Annotated answers to the review questions are provided
in a separate appendix.
Example 0.1 Example Source Code
We encourage experimenting with the code examples in order to reinforce the
material from the book. These can be downloaded from the book Web site (see
p. xli).
Java code is written in a mono-spaced font. Lines of code in the examples or in code
snippets are referenced in the text by a number, which is specified by using a
single-line comment in the code. For example, in the following code snippet, the
call to the method doSomethingInteresting() hopefully does something interesting
at (1).
Exam Objectives
0.1 Exam objectives are stated clearly at the start of every chapter.
0.2 The number in front of the objective identfies the objective as defined by 
Sun.
0.3 The objectives are organized into major sections, detailing the curriculum 
for the exam.
0.4 The exam objectives are reproduced in Appendix B where, for each section 
of the syllabus, references are included to point the reader to relevant topics 
for the exam.
Supplementary Objectives
• Supplementary objectives cover topics that are not on the exam, but which 
we believe are important for mastering the topics that are on the exam.
• Any supplementary objectives are listed as bullets at the beginning of a 
chapter.
xl PREFACE
// ...
doSomethingInteresting(); // (1)
// ...
Names of classes and interfaces start with an uppercase letter. Names of packages,
variables, and methods start with a lowercase letter. Constants are all in uppercase
letters. Interface names begin with the prefix 'I'. Coding conventions are followed, except when we have had to deviate in the interest of space or clarity.
Chapter Summary
Each chapter concludes with a summary of the topics, pointing out the major concepts discussed in the chapter.
Programming Exercises
Programming exercises at the end of each chapter provide the opportunity to put
concepts into practice. Solutions to the programming exercises are provided in a
separate appendix.
Mock Exam
A complete mock exam is provided in a separate appendix, which the reader can
try when she is ready.
Java SE API Documentation
In order to obtain optimal benefit from using this book in preparing for the SCJP
1.6 exam, we strongly recommend installing the latest version (1.6 or newer) of the
JDK and its accompanying API documentation. The book focuses solely on Java,
and does not acknowledge previous versions.
Java Platform Upgrade Exam
For those who have taken the Sun Certified Programmer for Java Platform 1.5
Exam, and would like to prepare for the Sun Certified Programmer for Java Platform 1.6 Upgrade Exam, we have provided an appendix with details of the
upgrade exam. The appendix contains the upgrade exam objectives, and for each
section of the syllabus, references are included to point the reader to topics essential for the upgrade exam.
A vertical gray bar is used to highlight methods and fields found in the classes
of the core Java APIs.
Any explanation following the API information is also similarly highlighted.
PREFACE xli
Book Web Site
This book is backed by a Web site providing auxiliary material:
http://www.ii.uib.no/~khalid/pgjc3e/
The contents of the Web site include the following:
• source code for all the examples and programming exercises in the book
• mock exam engine
• errata
• links to miscellaneous Java resources (certification, discussion groups, tools, etc.)
Information about the Java Standard Edition and its documentation can be found
at the following Web site:
http://java.sun.com/javase/
The current authoritative technical reference for the Java programming language,
The Java Language Specification, Third Edition (also published by Addison-Wesley),
can be found at this Web site:
http://java.sun.com/docs/books/jls/
Request for Feedback
Considerable effort has been made to ensure the accuracy of the contents of this
book. Several Java professionals have proofread the manuscript. All code
examples (including code fragments) have been compiled and tested on various
platforms. In the final analysis, any errors remaining are the sole responsibility of
the authors.
Any questions, comments, suggestions, and corrections are welcome. Let us know
whether the book was helpful or detrimental for your purposes. Any feedback is
valuable. The authors can be reached by the following e-mail alias:
pgjc3e@ii.uib.no
About the Authors
Khalid A. Mughal
Khalid A. Mughal is an Associate Professor at the Department of Informatics at
the University of Bergen, Norway. Professor Mughal is responsible for designing
and implementing various courses, which use Java, at the Department of Informatics. Over the years, he has taught Programming Languages (Java, C/C++,
Pascal), Software Engineering (Object-Oriented System Development), Data-
xlii PREFACE
bases (Data Modeling and Database Management Systems), and Compiler Techniques. He has also given numerous courses and seminars at various levels in
object-oriented programming and system development, using Java and Javarelated technology, both at the University and for the IT industry. He is the principal author of the book, responsible for writing the material covering the Java
topics.
Professor Mughal is also the principal author of an introductory Norwegian textbook on programming in Java (Java som første programmeringsspråk/Java as First Programming Language, Third Edition, Cappelen Akademisk Forlag, ISBN-10: 82-02-
24554-0, 2006), which he co-authored with Torill Hamre and Rolf W. Rasmussen.
Together they have also published another textbook for a 2-semester course in programming (Java Actually: A Comprehensive Primer in Programming, Cengage Learning, ISBN-10: 1844809331, 2008).
His current work involves applying Object Technology in the development of content management systems for publication on the Web, and security issues related
to web applications. For the past seven years he has been responsible for developing and running web-based programming courses in Java, which are offered to offcampus students.
He is also a member of the Association for Computing Machinery (ACM).
Rolf W. Rasmussen
Rolf W. Rasmussen is the System Development Manager at vizrt, a company that
develops solutions for the TV broadcast industry, including real-time 3D graphic
renderers, and content and control systems.
Rasmussen works mainly on control and automation systems, video processing,
typography, and real-time visualization. He has worked on clean room implementations of the Java class libraries in the past, and is a contributor to the Free Software Foundation.
Over the years, Rasmussen has worked both academically and professionally with
numerous programming languages, including Java. He is primarily responsible
for developing the review questions and answers, the programming exercises and
their solutions, the mock exam, and all the practical aspects related to taking the
SCJP exam presented in this book.
As mentioned above, he is also a co-author of two introductory textbooks on programming in Java. 
Acknowledgments (First Edition)
A small application for drawing simple shapes is used in the book to illustrate
various aspects of GUI building. The idea for this application, as far as we know,
PREFACE xliii
first appeared in Appendix D of Data Structures and Problem Solving Using Java
(M.A. Weiss, Addison-Wesley, 1998).
At Addison-Wesley-Longman (AWL), we would like to thank Emma Mitchell for
the support and the guidance she provided us right from the start of this project,
Martin Klopstock at AWL for accommodating the non-standard procedure
involved in getting the book to the printing press, Clive Birks at CRB Associates for
providing the professional look to the contents of this book, and finally, Sally
Mortimore at AWL for seeing us over the finishing line. The efforts of other professionals behind the scenes at AWL are also acknowledged.
Many reviewers have been involved during the course of writing this book. First
of all, we would like to thank the five anonymous reviewers commissioned by
AWL to review the initial draft. Their input was useful in the subsequent writing
of this book.
Several people have provided us with feedback on different parts of the material
at various stages: Jon Christian Lønningdal, Tord Kålsrud, Kjetil Iversen, Roy
Oma, and Arne Løkketangen. Their help is hereby sincerely acknowledged.
We are also very grateful to Laurence Vanhelsuwé, Kris Laporte, Anita Jacob, and
Torill Hamre for taking on the daunting task of reviewing the final draft, and
providing us with extensive feedback at such short notice. We would like to thank
Marit Mughal for reading the manuscript with the trained eye of a veteran English
schoolteacher.
We now understand why family members are invariably mentioned in a preface.
Without our families’ love, support, and understanding this book would have
remained a virtual commodity. Khalid would like to thank Marit, Nina, and Laila
for their love, and for being his pillars of support, during the writing of this book.
Thanks also to the folks in Birmingham for cheering us on. Rolf would like to thank
Liv, Rolf V., Knut, and Elisabeth for enduring the strange working hours producing
this book has entailed. A special thanks to Marit for providing us with scrumptious
dinners for consumption at the midnight hour.
Acknowledgments (Second Edition)
Feedback from many readers helped us to improve the first edition. We would like
to thank the following readers for their input in this effort: 
Michael F. Adolf, Tony Alicea, Kåre Auglænd, Jorge L. Barroso, Andre Beland, Darren Bruning, Paul Campbell, Roger Chang, Joanna Chappel, Laurian M Chirica,
Arkadi Choufrine, Barry Colston, John Cotter, Frédéric Demers, Arthur De Souza,
djc, William Ekiel, Darryl Failla, John Finlay, Christopher R. Gardner, Marco Garcia, Peter Gieser, George, Paul Graf, Shyamsundar Gururaj, Ray Ho, Leonardo
Holanda, Zhu Hongjun, Kara Van Horn, Peter Horst, Nain Hwu, Kent Johnson,
Samir Kanparia, Oleksiy Karpenko, Jeffrey Kenyon, Young Jin Kim, Kenneth
xliv PREFACE
Kisser, Billy Kutulas, Yi-Ming Lai, Robert M. Languedoc, Steve Lasley, Winser Lo,
Naga Madipalli, Craig Main, Avinash Mandsaurwale, Thomas Mathai, S. Mehra,
Yuan Meng, Simon Miller, William Moore, Anders Morch, George A. Murakami,
Sandy Nemecek, Chun Pan, Abigail García Patiño, Anil Philip, Alfred Raouf, Peter
Rorden, Christian Seifert, Gurpreet Singh, Christopher Stanwood, Swaminathan
Subramanian, Siva Sundaram, Manju Swamy, John Sweeney, Harmon Taylor,
Andrew Tolopko, Ravi Verma, Per J. Walstrøm, Chun Wang, James Ward, Winky,
Chun Wang, Jimmy Yang, Jennie Yip, Yanqu Zhou, and Yingting Zhou.
At the UK office of Addison-Wesley/Pearson Education, we would like to thank
our former editor Simon Plumtree for his unceasing support and patience while
we slogged on with the second edition. We would also like to acknowledge the
help and support of the following professionals, past and present, at the London
office: Alison Birtwell, Sally Carter, Karen Sellwood and Katherin Ekstrom. A special thanks to Karen Mosman (who has since moved on to another job) for her
encouragement and advice.
During the last lap of getting the book to the printing press, we were in the capable
hands of Ann Sellers at the US office of Addison-Wesley/Pearson Education. We
would like to acknowledge her efforts and that of other professionals—in particular, Greg Doench, Jacquelyn Doucette, Amy Fleischer, Michael Mullen, and Dianne
Russell—who helped to get this book through the door and on to the bookshelf.
Thanks also to Mike Hendrickson for always lending an ear when we met at the
OOPSLA conferences, and pointing us in the right direction with our book plans.
We would like to thank the folks at Whizlabs Software for their collaboration in
producing the contents for the CD accompanying this book. Those guys certainly know the business of developing exam simulators for certification in Java
technology.
We were fortunate in having two Java gurus—Laurence Vanhelsuwé and Marcus
Green—to do the technical review of the second edition. As he did for the first edition, Laurence came through and provided us with invaluable feedback, from the
minutiae of writing technical books to many technical issues relating to the Java
programming language. Marcus put the manuscript through his severe certification scrutiny regarding the specifics of the SCJP exam. We are sorry to have upset
their plans for Easter holidays, and hasten to thank them most profusely for taking
on the task.
We cannot thank enough our own in-house, private copy-editor: Marit Seljeflot
Mughal. She diligently and relentlessly read numerous drafts of the manuscript,
usually at very short notice. Marit claims that if she understood what we had written, then a computer-literate person should have no problem whatsoever. This
claim remains to be substantiated. If any commas are not used correctly, then it is
entirely our fault, in spite of being repeatedly shown how to use them.
We are also indebted to many Java-enabled individuals for providing us valuable
feedback on parts of the manuscript for the second edition. This includes Pradeep
Chopra, Seema R., and Gaurav Kohli at Whizlabs Software. Unfortunately for us,
PREFACE xlv
they only had time to read part of the manuscript. Thanks also to Torill Hamre at
the Nansen Environmental and Remote Sensing Center, Bergen, for her useful
comments and suggestions. We also thank the following Master students at the
Department of Informatics, University of Bergen, for providing useful feedback:
Mikal Carlsen, Yngve Espelid, Yngve A. Aas, Sigmund Nysæter, Torkel Holm, and
Eskil Saatvedt.
Family support saw us through this writing project as well. Our families have put
up with our odd and long working hours, endured our preoccupation and our
absence at the dining table. Khalid would like to acknowledge the love and support of his wife, Marit, and daughters, Nina and Laila, while working on this book.
Rolf would like to thank Liv, Rolf V., Knut, and Elisabeth for their love, patience
and support.
Acknowledgments (Third Edition)
Many readers have sent us e-mails testifying that the Programmer’s Guide contributed toward their success on the exam. That is the best advertisement we can hope
for. The feedback we have received since the publication of the second edition has
had an impact on improving the third edition. In particular, we would like to thank
the following diligent readers for their contributions:
Bret ABMac, Einar Andresen, Brian Bradshaw, Nicola Cammillini, Juan Carlos
Castro, Sweta Doshi, David Featherstone, Danish Halim, Niels Harremoës, John
Holcroft, Leong Jern-Kuan, Rajesh Kesarwani, Ken Kisser, Shampa Kumar, Tony
LaPaso, Kaydell Leavitt, Luba Leyzerenok, Adam Lorentzon, Chuck Meier, Philip
Mitchell, Sigmund Nysæter, Pat Owens, Sanket Reddy, Raul Saavedra, Oliver Schoettler, Wayne Schroeter, Mark Sullivan, Myoung Son, Bob Souther, Anthony Tang,
Frederik Uyttersprot.
Erik Ernst was kind enough to review the chapter on Java generics, for which we
are very grateful. The generics chapter was also reviewed by Erik Andreas Brandstadmoen and Kristian Berg. Our sincere thanks to all of you. The pages of feedback we received helped to clarify many subtleties, and made us realize that some
dark corners of Java generics are best avoided by mere mortals.
Selected chapters for the third edition were also vetted by the following Java developers in the Bergen area: Olve Hansen, David J.M. Karlsen and Lars Søraas. Many
thanks for taking time out from your busy schedule to provide us with your feedback. Our thanks also to Helge W. Johnsen and Amund Trovåg for feedback on
review questions regarding new features in Java 1.5.
Our award for Reviewer Par Excellence goes to Jennie Yip. The meticulous notes
she provided for the ten chapters of the second edition have had a profound effect
on shaping the third edition. Any chance that the feat can be repeated with the
third edition? Please name your price.
xlvi PREFACE
This time around we were again fortunate enough to have Marcus Green as our
technical reviewer. We have heeded his feedback that has kept us, we hope, on the
straight and narrow as far as the exam is concerned, and curbed our enthusiasm
for including every Java topic that we fancied. Our sincere thanks for the review
you provided us.
At Pearson, we would like to thank Greg Doench and Michelle Housley for managing the publication of this edition. We are also grateful to the people behind the
scenes at Pearson who helped get the book to the printing press.
Khalid would like to thank the Computer Science Department at Cornell University, where he spent a significant part of his sabbatical (Fall 2007/Spring 2008)
working on the third edition. A better place for such an endeavour would be hard
to come by.
We cannot thank enough Marit Seljeflot Mughal who has been our personal quality
controller, acting as an amalgamated draft reader, copy editor, and proofreader.
What she sanctioned we could confidently allow to be seen by the light of day, saving us many embarrassing mistakes, both technical and non-technical. We don’t
know if it is for us or for the love of Java that you scrutinize the endless drafts that
we lay in your path.
Any mistakes or errors remaining are an oversight on our part. Rest assured that
every possible effort has been made to get the facts straight.
Without family support this edition would still be wishful thinking. Khalid would
like to thank Marit, Laila, Nina and Kenneth for their love, support and understanding—particularly, while working on this book.
—Khalid A. Mughal
Rolf W. Rasmussen
September 2008
Ithaca, New York, USA
Bergen, Norway
1
1 Basics of Java Programming
Supplementary Objectives
• Introduce the basic terminology and concepts in object-oriented 
programming: classes, objects, references, fields, methods, members, 
inheritance, aggregation.
• Identify the essential elements of a Java program.
• Learn how to compile and run a Java program.
2 CHAPTER 1: BASICS OF JAVA PROGRAMMING
1.1 Introduction
Before embarking on the road to Java programmer certification, it is important to
understand the basic terminology and concepts in object-oriented programming
(OOP). In this chapter, the emphasis is on providing an introduction rather than
exhaustive coverage. In-depth coverage of the concepts follows in subsequent
chapters of the book.
Java supports the writing of many different kinds of executables: applications,
applets, and servlets. The basic elements of a Java application are introduced in
this chapter. The old adage that practice makes perfect is certainly true when learning a programming language. To encourage programming on the computer, the
mechanics of compiling and running a Java application are outlined.
1.2 Classes
One of the fundamental ways in which we handle complexity is in abstractions. An
abstraction denotes the essential properties and behaviors of an object that
differentiate it from other objects. The essence of OOP is modelling abstractions,
using classes and objects. The hard part in this endeavor is finding the right
abstraction.
A class denotes a category of objects, and acts as a blueprint for creating such
objects. A class models an abstraction by defining the properties and behaviors for
the objects representing the abstraction. An object exhibits the properties and
behaviors defined by its class. The properties of an object of a class are also called
attributes, and are defined by fields in Java. A field in a class is a variable which can
store a value that represents a particular property of an object. The behaviors of an
object of a class are also known as operations, and are defined using methods in Java.
Fields and methods in a class declaration are collectively called members.
An important distinction is made between the contract and the implementation that
a class provides for its objects. The contract defines what services, and the implementation defines how these services are provided by the class. Clients (i.e., other
objects) only need to know the contract of an object, and not its implementation, in
order to avail themselves of the object’s services.
As an example, we will implement different versions of a class that models the
abstraction of a stack that can push and pop characters. The stack will use an array
of characters to store the characters, and a field to indicate the top element in the
stack. Using Unified Modeling Language (UML) notation, a class called CharStack
is graphically depicted in Figure 1.1, which models the abstraction. Both fields and
method names are shown in Figure 1.1a.
1.2: CLASSES 3
Declaring Members: Fields and Methods
Example 1.1 shows the declaration of the class CharStack depicted in Figure 1.1. Its
intention is to illustrate the salient features of a class declaration in Java, and not
the effective implementation of stacks. 
A class declaration consists of a series of member declarations. In the case of the
class CharStack, it has two fields declared at (1):
• stackArray, which is an array to hold the elements of the stack (in this case,
characters)
• topOfStack, which denotes the top element of the stack (i.e., the index of the last
character stored in the array)
The class CharStack has five methods, declared at (3), that implement the essential
operations on a stack:
• push() pushes a character on to the stack
• pop() removes and returns the top element of the stack
• peek() returns the top element of the stack for inspection
• isEmpty() determines whether the stack is empty
• isFull() determines whether the stack is full
The class declaration also has a method-like declaration with the same name as the
class, (2). Such declarations are called constructors. As we shall see, a constructor is
executed when an object is created from the class. However, the implementation
details in the example are not important for the present discussion.
Example 1.1 Basic Elements of a Class Declaration
//Source Filename: CharStack.java
public class CharStack { // Class name
 // Class Declarations:
Figure 1.1 UML Notation for Classes
CharStack
stackArray
peek()
topOfStack
push()
pop()
CharStack
(a) Expanded Form
isFull()
isEmpty()
(b) Abbreviated Form
Fields
Methods
Class Name
4 CHAPTER 1: BASICS OF JAVA PROGRAMMING
 // Fields: (1)
 private char[] stackArray; // The array implementing the stack.
 private int topOfStack; // The top of the stack.
 // Constructor: (2)
 public CharStack(int capacity) {
 stackArray = new char[capacity];
 topOfStack = -1;
 }
 // Methods: (3)
 public void push(char element) { stackArray[++topOfStack] = element; }
 public char pop() { return stackArray[topOfStack--]; }
 public char peek() { return stackArray[topOfStack]; }
 public boolean isEmpty() { return topOfStack < 0; }
 public boolean isFull() { return topOfStack == stackArray.length - 1; }
}
1.3 Objects
Class Instantiation, Reference Values, and References
The process of creating objects from a class is called instantiation. An object is an
instance of a class. The object is constructed using the class as a blueprint and is
a concrete instance of the abstraction that the class represents. An object must be
created before it can be used in a program. 
A reference value is returned when an object is created. A reference value denotes a
particular object. An object reference (or simply reference) is a variable that can store
a reference value. A reference thus provides a handle to an object, as it can indirectly denote an object whose reference value it holds. In Java, an object can only
be manipulated via its reference value, or equivalently by a reference that holds its
reference value. 
The process of creating objects usually involves the following steps:
1. Declaration of a variable to store the reference value of an object.
This involves declaring a reference variable of the appropriate class to store the
reference value of the object.
// Declaration of two reference variables that will refer to
// two distinct objects, namely two stacks of characters, respectively.
CharStack stack1, stack2;
2. Creating an object.
This involves using the new operator in conjunction with a call to a constructor,
to create an instance of the class.
// Create two distinct stacks of chars.
1.3: OBJECTS 5
stack1 = new CharStack(10); // Stack length: 10 chars
stack2 = new CharStack(5); // Stack length: 5 chars
The new operator creates an instance of the CharStack class and returns the reference value of this instance. The reference value can be assigned to a reference
variable of the appropriate class. The reference variable can then be used to
manipulate the object whose reference value is stored in the reference variable. 
Each object has its own copy of the fields declared in the class declaration. The
two stacks, referenced by stack1 and stack2, will have their own stackArray and
topOfStack fields.
The purpose of the constructor call on the right side of the new operator is
to initialize the newly created object. In this particular case, for each new
CharStack instance created using the new operator, the constructor creates an
array of characters. The length of this array is given by the value of the argument to the constructor. The constructor also initializes the topOfStack field.
The declaration of a reference and the instantiation of the class can also be combined, as in the following declaration statement:
CharStack stack1 = new CharStack(10),
 stack2 = new CharStack(5);
Figure 1.2 shows the UML notation for objects. The graphical representation of an
object is very similar to that of a class. Figure 1.2 shows the canonical notation,
where the name of the reference variable denoting the object is prefixed to the class
name with a colon (':'). If the name of the reference variable is omitted, as in Figure 1.2b, this denotes an anonymous object. Since objects in Java do not have
names, but are denoted by references, a more elaborate notation is shown in Figure
1.2c, where objects representing references of the CharStack class explicitly refer to
CharStack objects. In most cases, the more compact notation will suffice.
Figure 1.2 UML Notation for Objects
:CharStack
(c) Explicit References for Java Objects 
stack2:CharStack
(a) Standard Notation for Objects 
stack1:Ref(CharStack) :CharStack
:CharStack
(b) Anonymous Object 
stack2:Ref(CharStack)
stack1:CharStack
6 CHAPTER 1: BASICS OF JAVA PROGRAMMING
Object Aliases
An object can be referred by several references, meaning that they store the reference value of the same object. Such references are called aliases. The object can be
manipulated via any one of its aliases, as each one refers to the same object.
// Create two distinct stacks of chars.
CharStack stackA = new CharStack(12); // Stack length: 12 chars
CharStack stackB = new CharStack(6); // Stack length: 6 chars
stackB = stackA; // (1) aliases after assignment
// The stack previously referenced by stackB can now be garbage collected.
Two stacks are created in the code above. Before the assignment at (1), the situation
is as depicted in Figure 1.3a. After the assignment at (1), the reference variables
stackA and stackB will denote the same stack, as depicted in Figure 1.3b. The reference value in stackA is assigned to stackB. The reference variables stackA and stackB
are aliases after the assignment, as they refer to the same object. What happens to
the stack object that was denoted by the reference variable stackB before the assignment? When objects are no longer in use, their memory is, if necessary, reclaimed
and reallocated for other objects. This is called automatic garbage collection. Garbage
collection in Java is taken care of by the runtime system. 
1.4 Instance Members
Each object created will have its own copies of the fields defined in its class. The
fields of an object are called instance variables. The values of the instance variables
in an object comprise its state. Two distinct objects can have the same state, if their
instance variables have the same values. The methods of an object define its behavior. These methods are called instance methods. It is important to note that these
methods pertain to each object of the class. This should not be confused with the
Figure 1.3 Aliases
stackA:Ref(CharStack) :CharStack 
stackB:Ref(CharStack) :CharStack 
stackA:Ref(CharStack) :CharStack 
stackB:Ref(CharStack) :CharStack 
(a) Before 
(b) After Assignment
1.5: STATIC MEMBERS 7
implementation of the methods, which is shared by all instances of the class.
Instance variables and instance methods, which belong to objects, are collectively
called instance members, to distinguish them from static members, which belong to
the class only. Static members are discussed in Section 1.5.
Invoking Methods
Objects communicate by message passing. This means that an object can be made
to exhibit a particular behavior by sending the appropriate message to the object.
In Java, this is done by calling a method on the object using the binary infix dot
('.') operator. A method call spells out the complete message: the object that is the
receiver of the message, the method to be invoked, and the arguments to the
method, if any. The method invoked on the receiver can also send information back
to the sender, via a single return value. The method called must be one that is
defined for the object, otherwise the compiler reports an error.
CharStack stack = new CharStack(5); // Create a stack
stack.push('J'); // (1) Character 'J' pushed
char c = stack.pop(); // (2) One character popped and returned: 'J'
stack.printStackElements(); // (3) Compile-time error: No such method in CharStack
The sample code above invokes methods on the object denoted by the reference
variable stack. The method call at (1) pushes one character on the stack, and the
method call at (2) pops one character off the stack. Both push() and pop() methods
are defined in the class CharStack. The push() method does not return any value, but
the pop() method returns the character popped. Trying to invoke a method named
printStackElements on the stack results in a compile-time error, as no such method
is defined in the class CharStack.
The dot ('.') notation can also be used with a reference to access the fields of an
object. The use of the dot notation is governed by the accessibility of the member.
The fields in the class CharStack have private accessibility, indicating that they are
not accessible from outside the class:
stack.topOfStack++; // Compile-time error: topOfStack is a private field.
1.5 Static Members
In some cases, certain members should only belong to the class, and not be part of
any object created from the class. An example of such a situation is when a class
wants to keep track of how many objects of the class have been created. Defining
a counter as an instance variable in the class declaration for tracking the number of
objects created does not solve the problem. Each object created will have its own
counter field. Which counter should then be updated? The solution is to declare the
counter field as being static. Such a field is called a static variable. It belongs to the
class, and not to any object of the class. A static variable is initialized when the class
is loaded at runtime. Similarly, a class can have static methods that belong to the
8 CHAPTER 1: BASICS OF JAVA PROGRAMMING
class, and not to any specific objects of the class. Static variables and static methods
are collectively known as static members, and are declared with the keyword static.
Figure 1.4 shows the class diagram for the class CharStack. It has been augmented
by two static members that are shown underlined. The augmented definition of the
CharStack class is given in Example 1.2. The field counter is a static variable declared
at (1). It will be allocated and initialized to the default value 0 when the class is
loaded. Each time an object of the CharStack class is created, the constructor at (2)
is executed. The constructor explicitly increments the counter in the class. The
method getInstanceCount() at (3) is a static method belonging to the class. It returns
the counter value when called.
Example 1.2 Static Members in Class Declaration
//Filename CharStack.java
public class CharStack {
 // Instance variables:
 private char[] stackArray; // The array implementing the stack.
 private int topOfStack; // The top of the stack.
 // Static variable
 private static int counter; // (1)
 // Constructor now increments the counter for each object created.
 public CharStack(int capacity) { // (2)
 stackArray = new char[capacity];
 topOfStack = -1;
 counter++;
 }
 // Instance methods:
 public void push(char element) { stackArray[++topOfStack] = element; }
 public char pop() { return stackArray[topOfStack--]; }
 public char peek() { return stackArray[topOfStack]; }
 public boolean isEmpty() { return topOfStack < 0; }
 public boolean isFull() { return topOfStack == stackArray.length - 1; }
Figure 1.4 Class Diagram Showing Static Members of a Class
CharStack
stackArray
...
peek()
topOfStack
push()
pop()
counter
getInstanceCount()
1.5: STATIC MEMBERS 9
 // Static method (3)
 public static int getInstanceCount() { return counter; }
}
Figure 1.5 shows the classification of the members in the class CharStack using the
terminology we have introduced so far. Table 1.1 at the end of this section, provides
a summary of the terminology used in defining members of a class.
Clients can access static members in the class by using the class name. The following code invokes the getInstanceCount() method in the class CharStack:
int count = CharStack.getInstanceCount(); // Class name to invoke static method
Static members can also be accessed via object references, but this is considered
bad style:
CharStack stack1;
int count1 = stack1.getInstanceCount(); // Reference invokes static method
Static members in a class can be accessed both by the class name and via object references, but instance members can only be accessed by object references.
Figure 1.5 Members of a Class
Class Name CharStack
Static members belong to the class
Objects
stackArray
topOfStack
Instance variables
push()
pop()
peek()
isEmpty()
isFull()
Instance methods
Instance members belong to objects
Methods
Fields
Members
Class
Static variables
counter
Static methods
getInstanceCount()
Attributes
Behaviour
10 CHAPTER 1: BASICS OF JAVA PROGRAMMING
1.6 Inheritance
There are two fundamental mechanisms for building new classes from existing
ones: inheritance and aggregation. It makes sense to inherit from an existing class
Vehicle to define a class Car, since a car is a vehicle. The class Vehicle has several
parts; therefore, it makes sense to define a composite object of the class Vehicle that
has constituent objects of such classes as Motor, Axle, and GearBox, which make up a
vehicle.
Inheritance is illustrated by an example that implements a stack of characters that
can print its elements on the terminal. This new stack has all the properties and
behaviors of the CharStack class, but it also has the additional capability of printing
its elements. Given that this printable stack is a stack of characters, it can be
derived from the CharStack class. This relationship is shown in Figure 1.6. The class
PrintableCharStack is called the subclass, and the class CharStack is called the superclass. The CharStack class is a generalization for all stacks of characters, whereas the
Table 1.1 Terminology for Class Members
Instance Members These are instance variables and instance methods of an 
object. They can only be accessed or invoked through an 
object reference.
Instance Variable A field that is allocated when the class is instantiated, i.e., 
when an object of the class is created. Also called non-static
field.
Instance Method A method that belongs to an instance of the class. Objects of 
the same class share its implementation.
Static Members These are static variables and static methods of a class. They 
can be accessed or invoked either by using the class name or 
through an object reference.
Static Variable A field that is allocated when the class is loaded. It belongs 
to the class and not to any specific object of the class. Also 
called static field or class variable.
Static Method A method which belongs to the class and not to any object of 
the class. Also called class method.
Figure 1.6 Class Diagram Depicting Inheritance Relationship
PrintableCharStack
Superclass
Subclass
Generalization
Specialization

 
CharStack
1.6: INHERITANCE 11
class PrintableCharStack is a specialization of stacks of characters that can also print
their elements.
In Java, deriving a new class from an existing class requires the use of the extends
clause in the subclass declaration. A subclass can extend only one superclass. The
subclass can inherit members of the superclass. The following code fragment
implements the PrintableCharStack class:
class PrintableCharStack extends CharStack { // (1)
 // Instance method
 public void printStackElements() { // (2)
 // ... implementation of the method...
 }
 // The constructor calls the constructor of the superclass explicitly.
 public PrintableCharStack(int capacity) { super(capacity); } // (3)
}
The PrintableCharStack class extends the CharStack class at (1). Implementing the
printStackElements() method in the PrintableCharStack class requires access to the
field stackArray from the superclass CharStack. However, this field is private and
therefore not accessible in the subclass. The subclass can access these fields if the
accessibility of the fields is changed to protected in the CharStack class. Example 1.3
uses a version of the class CharStack, which has been modified accordingly. Implementation of the printStackElements() method is shown at (2). The constructor of
the PrintableCharStack class at (3) calls the constructor of the superclass CharStack
in order to initialize the stack properly.
Example 1.3 Defining a Subclass
// Source Filename: CharStack.java
public class CharStack {
 // Instance variables
 protected char[] stackArray; // The array that implements the stack.
 protected int topOfStack; // The top of the stack.
 // The rest of the definition is the same as in Example 1.2.
}
//Filename: PrintableCharStack.java
public class PrintableCharStack extends CharStack { // (1)
 // Instance method
 public void printStackElements() { // (2)
 for (int i = 0; i <= topOfStack; i++)
 System.out.print(stackArray[i]); // print each char on terminal
 System.out.println();
 }
 // Constructor calls the constructor of the superclass explicitly.
 PrintableCharStack(int capacity) { super(capacity); } // (3)
}
12 CHAPTER 1: BASICS OF JAVA PROGRAMMING
Objects of the PrintableCharStack class will respond just like the objects of the CharStack class, but they will also have the additional functionality defined in the
subclass:
PrintableCharStack pcStack = new PrintableCharStack(3);
pcStack.push('H');
pcStack.push('i');
pcStack.push('!');
pcStack.printStackElements(); // Prints "Hi!" on the terminal
1.7 Aggregation
When building new classes from existing classes using aggregation, a composite
object is built from the constituent objects that are its parts.
Java supports aggregation of objects by reference, since objects cannot contain
other objects explicitly. The fields can only contain values of primitive data types
or reference values to other objects. Each object of the CharStack class has a field to
store the reference value of an array object that holds the characters. Each stack
object also has a field of primitive data type int to store the index value that
denotes the top of stack. This is reflected in the definition of the CharStack class,
which contains an instance variable for each of these parts. In contrast to the
constituent objects whose reference values are stored in fields, the values of primitive data types are themselves stored in the fields of the composite object. The
aggregation relationship is depicted by the UML diagram in Figure 1.7, showing
that each object of the CharStack class will have one array object of type char associated with it.
Figure 1.7 Class Diagram Depicting Aggregation
CharStack 
stackArray 
topOfStack 
push() 
pop() 
peek() 
... 
Array of char 1 
has
1.8: TENETS OF JAVA 13
1.8 Tenets of Java
• Code in Java must be encapsulated in classes.
• There are two kinds of values in Java: there are objects that are instances of
classes or arrays, and there are atomic values of primitive data types.
• References denote objects and are used to manipulate objects.
• Objects in Java cannot contain other objects; they can only contain references to
other objects.
• During execution, reclamation of objects that are no longer in use is managed
by the runtime system.
Review Questions
1.1 Which statement about methods is true?
Select the one correct answer.
(a) A method is an implementation of an abstraction.
(b) A method is an attribute defining the property of a particular abstraction.
(c) A method is a category of objects.
(d) A method is an operation defining the behavior for a particular abstraction.
(e) A method is a blueprint for making operations.
1.2 Which statement about objects is true?
Select the one correct answer.
(a) An object is what classes are instantiated from.
(b) An object is an instance of a class.
(c) An object is a blueprint for creating concrete realization of abstractions.
(d) An object is a reference.
(e) An object is a variable.
1.3 Which is the first line of a constructor declaration in the following code?
public class Counter { // (1)
 int current, step;
 public Counter(int startValue, int stepValue) { // (2)
 setCurrent(startValue);
 setStep(stepValue);
 }
 public int getCurrent() { return current; } // (3)
 public void setCurrent(int value) { current = value; } // (4)
 public void setStep(int stepValue) { step = stepValue; } // (5)
}
14 CHAPTER 1: BASICS OF JAVA PROGRAMMING
Select the one correct answer.
(a) (1)
(b) (2)
(c) (3)
(d) (4)
(e) (5)
1.4 Given that Thing is a class, how many objects and how many reference variables are
created by the following code?
Thing item, stuff;
item = new Thing();
Thing entity = new Thing();
Select the two correct answers.
(a) One object is created.
(b) Two objects are created.
(c) Three objects are created.
(d) One reference variable is created.
(e) Two reference variables are created.
(f) Three reference variables are created.
1.5 Which statement about instance members is true?
Select the one correct answer.
(a) An instance member is also called a static member.
(b) An instance member is always a field.
(c) An instance member is never a method.
(d) An instance member belongs to an instance, not to the class as a whole.
(e) An instance member always represents an operation.
1.6 How do objects communicate in Java?
Select the one correct answer.
(a) They communicate by modifying each other’s fields.
(b) They communicate by modifying the static variables of each other’s classes.
(c) They communicate by calling each other’s instance methods.
(d) They communicate by calling static methods of each other’s classes.
1.7 Given the following code, which statements are true?
class A {
 int value1;
}
class B extends A {
 int value2;
}
1.10: SAMPLE JAVA APPLICATION 15
Select the two correct answers.
(a) Class A extends class B.
(b) Class B is the superclass of class A.
(c) Class A inherits from class B.
(d) Class B is a subclass of class A.
(e) Objects of class A have a field named value2.
(f) Objects of class B have a field named value1.
1.9 Java Programs
A Java source file can contain more than one class declaration. Each source file name
has the extension .java. The JDK enforces the rule that any class in the source file
that has public accessibility must be declared in its own file; meaning that such a
public class must be declared in a source file whose file name comprises the name
of this public class with .java as its extension. The above rule implies that a source
file can only contain at the most one public class. If the source file contains a public
class, the file naming rule must be obeyed.
Each class declaration in a source file is compiled into a separate class file, containing Java byte code. The name of this file comprises the name of the class with .class
as its extension. The JDK provides tools for compiling and running programs, as
explained in the next section. The classes in the Java standard library are already
compiled, and the JDK tools know where to find them.
1.10 Sample Java Application
An application is just a synonym for a program: source code that is compiled and
directly executed. In order to create an application in Java, the program must have
a class that defines a method named main, which is the starting point for the execution of any application.
Essential Elements of a Java Application
Example 1.4 is an example of an application in which a client uses the CharStack
class to reverse a string of characters.
Example 1.4 An Application
// Source Filename: CharStack.java
public class CharStack {
 // Same as in Example 1.2.
}
16 CHAPTER 1: BASICS OF JAVA PROGRAMMING
//Filename: Client.java
public class Client {
 public static void main(String[] args) {
 // Create a stack.
 CharStack stack = new CharStack(40);
 // Create a string to push on the stack:
 String str = "!no tis ot nuf era skcatS";
 int length = str.length();
 System.out.println("Original string: " + str);
 // Push the string char by char onto the stack:
 for (int i = 0; i < length; i++) {
stack.push(str.charAt(i));
 }
 System.out.print("Reversed string: ");
 // Pop and print each char from the stack:
 while (!stack.isEmpty()) { // Check if the stack is not empty.
 System.out.print(stack.pop());
 }
 System.out.println();
 }
}
Output from the program:
Original string: !no tis ot nuf era skcatS
Reversed string: Stacks are fun to sit on!
The public class Client defines a method with the name main. To start the application, the main() method in this public class is invoked by the Java interpreter, also
called the Java Virtual Machine (JVM). The method header of this main() method
should be declared as shown in the following method stub:
public static void main(String[] args) // Method header
{ /* Implementation */ }
The main() method has public accessibility, i.e., it is accessible from any class. The
keyword static means the method belongs to the class. The keyword void means
the method does not return any value. The parameter list, (String[] args), is an
array of strings that can be used to pass information to the main() method when the
application is started.
Compiling and Running an Application
Java source files can be compiled using the Java compiler tool javac, which is part
of the JDK.
1.10: SAMPLE JAVA APPLICATION 17
The source file Client.java contains the declaration of the Client class. The source
file can be compiled by giving the following command at the command line. (The
character > is the command prompt.)
>javac Client.java
This creates the class file Client.class containing the Java byte code for the Client
class. The Client class uses the CharStack class, and if the file CharStack.class does
not already exist, the compiler will also compile the source file CharStack.java.
Compiled classes can be executed by the Java interpreter java, which is also part of
the JDK. Example 1.4 can be run by giving the following command in the command line:
>java Client
Note that only the name of the class is specified, resulting in the execution starting
in the main() method of the specified class. The application in Example 1.4 terminates when the execution of the main() method is completed.
Review Questions
1.8 Which command from the JDK should be used to compile the following source
code contained in a file named SmallProg.java?
public class SmallProg {
 public static void main(String[] args) { System.out.println("Good luck!"); }
}
Select the one correct answer.
(a) java SmallProg
(b) javac SmallProg
(c) java SmallProg.java
(d) javac SmallProg.java
(e) java SmallProg main
1.9 Which command from the JDK should be used to execute the main() method of a
class named SmallProg?
Select the one correct answer.
(a) java SmallProg
(b) javac SmallProg
(c) java SmallProg.java
(d) java SmallProg.class
(e) java SmallProg.main()
18 CHAPTER 1: BASICS OF JAVA PROGRAMMING
Chapter Summary
The following information was included in this chapter:
• basic concepts in OOP, and how they are supported in Java
• essential elements of a Java application
• compiling and running Java applications
Programming Exercise
1.1 Modify the program from Example 1.4 to use the PrintableCharStack class,
rather than the CharStack class from Example 1.2. Utilize the printStackElements() method from the PrintableCharStack class. Is the new program behaviorwise any different from Example 1.4?
19
2 Language Fundamentals
Exam Objectives
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, 
and objects as static, instance, and local variables. Also, use legal 
identifiers for variable names.
❍ For arrays, see Section 3.6, p. 69.
❍ For enums, see Section 3.5, p. 54.
❍ For initializers, see Section 9.7, p. 406.
Supplementary Objectives
• Be able to identify the basic elements of the Java programming language: 
keywords, identifiers, literals and primitive data types.
• Understand the scope of variables.
• Understand initializing variables with default values.
20 CHAPTER 2: LANGUAGE FUNDAMENTALS
2.1 Basic Language Elements
Like any other programming language, the Java programming language is defined
by grammar rules that specify how syntactically legal constructs can be formed using
the language elements, and by a semantic definition that specifies the meaning of
syntactically legal constructs.
Lexical Tokens
The low-level language elements are called lexical tokens (or just tokens) and are the
building blocks for more complex constructs. Identifiers, numbers, operators, and
special characters are all examples of tokens that can be used to build high-level
constructs like expressions, statements, methods, and classes.
Identifiers
A name in a program is called an identifier. Identifiers can be used to denote classes,
methods, variables, and labels.
In Java, an identifier is composed of a sequence of characters, where each character
can be either a letter or a digit. However, the first character in an identifier must be
a letter. Since Java programs are written in the Unicode character set (see p. 23), the
definitions of letter and digit are interpreted according to this character set. Note
that connecting punctuation (such as underscore _) and any currency symbol (such as
$, ¢, ¥, or £) are allowed as letters, but should be avoided in identifier names.
Identifiers in Java are case sensitive, for example, price and Price are two different
identifiers.
Examples of Legal Identifiers
number, Number, sum_$, bingo, $$_100, mål, grüß
Examples of Illegal Identifiers
48chevy, all@hands, grand-sum
The name 48chevy is not a legal identifier as it starts with a digit. The character @ is
not a legal character in an identifier. It is also not a legal operator, so that all@hands
cannot be interpreted as a legal expression with two operands. The character - is
also not a legal character in an identifier. However, it is a legal operator so grandsum could be interpreted as a legal expression with two operands.
Keywords
Keywords are reserved words that are predefined in the language and cannot be
used to denote other entities. All the keywords are in lowercase, and incorrect
usage results in compilation errors.
2.1: BASIC LANGUAGE ELEMENTS 21
Keywords currently defined in the language are listed in Table 2.1. In addition,
three identifiers are reserved as predefined literals in the language: the null reference, and the boolean literals true and false (see Table 2.2). Keywords currently
reserved, but not in use, are listed in Table 2.3. A reserved word cannot be used as
an identifier. The index contains references to relevant sections where currently
used keywords are explained. 
Literals
A literal denotes a constant value, i.e., the value that a literal represents remains
unchanged in the program. Literals represent numerical (integer or floating-point),
character, boolean or string values. In addition, there is the literal null that represents the null reference.
Table 2.1 Keywords in Java
abstract default if private this
assert do implements protected throw
boolean double import public throws
break else instanceof return transient
byte enum int short try
case extends interface static void
catch final long strictfp volatile
char finally native super while
class float new switch
continue for package synchronized
Table 2.2 Reserved Literals in Java
null true false
Table 2.3 Reserved Keywords not Currently in Use
const goto
Table 2.4 Examples of Literals
Integer 2000 0 -7
Floating-point 3.14 -3.14 .5 0.5
Character 'a' 'A' '0' ':' '-' ')'
Boolean true false
String "abba" "3.14" "for" "a piece of the action"
22 CHAPTER 2: LANGUAGE FUNDAMENTALS
Integer Literals
Integer data types comprise the following primitive data types: int, long, byte, and
short (see Section 2.2, p. 28).
The default data type of an integer literal is always int, but it can be specified as
long by appending the suffix L (or l) to the integer value. Without the suffix, the
long literals 2000L and 0l will be interpreted as int literals. There is no direct way to
specify a short or a byte literal.
In addition to the decimal number system, integer literals can also be specified in
octal (base 8) and hexadecimal (base 16) number systems. Octal and hexadecimal
numbers are specified with a 0 and 0x (or 0X) prefix respectively. Examples of decimal, octal and hexadecimal literals are shown in Table 2.5. Note that the leading 0
(zero) digit is not the uppercase letter O. The hexadecimal digits from a to f can also
be specified with the corresponding uppercase forms (A to F). Negative integers
(e.g. -90) can be specified by prefixing the minus sign (-) to the magnitude of the
integer regardless of number system (e.g., -0132 or -0X5A). Number systems and
number representation are discussed in Appendix G. Java does not support literals
in binary notation.
Floating-Point Literals
Floating-point data types come in two flavors: float or double.
The default data type of a floating-point literal is double, but it can be explicitly
designated by appending the suffix D (or d) to the value. A floating-point literal can
also be specified to be a float by appending the suffix F (or f).
Floating-point literals can also be specified in scientific notation, where E (or e)
stands for Exponent. For example, the double literal 194.9E-2 in scientific notation is
interpreted as 194.9 × 10-2 (i.e., 1.949).
Table 2.5 Examples of Decimal, Octal, and Hexadecimal Literals
Decimal Octal Hexadecimal
8 010 0x8
10L 012L 0xaL
16 020 0x10
27 033 0x1B
90L 0132L 0x5aL
-90 -0132 -0x5A
2147483647 (i.e., 231-1) 017777777777 0x7fffffff
-2147483648 (i.e., -231) -020000000000 -0x80000000
1125899906842624L (i.e., 250) 040000000000000000L 0x4000000000000L
2.1: BASIC LANGUAGE ELEMENTS 23
Examples of double Literals
0.0 0.0d 0D
0.49 .49 .49D
49.0 49. 49D
4.9E+1 4.9E+1D 4.9e1d 4900e-2 .49E2
Examples of float Literals
0.0F 0f
0.49F .49F
49.0F 49.F 49F
4.9E+1F 4900e-2f .49E2F
Note that the decimal point and the exponent are optional and that at least one
digit must be specified.
Boolean Literals
The primitive data type boolean represents the truth-values true or false that are
denoted by the reserved literals true or false, respectively.
Character Literals
A character literal is quoted in single-quotes ('). All character literals have the
primitive data type char.
A character literal is represented according to the 16-bit Unicode character set,
which subsumes the 8-bit ISO-Latin-1 and the 7-bit ASCII characters. In Table 2.6,
note that digits (0 to 9), upper-case letters (A to Z), and lower-case letters (a to z) have
contiguous Unicode values. A Unicode character can always be specified as a fourdigit hexadecimal number (i.e., 16 bits) with the prefix \u.
Table 2.6 Examples of Character Literals
Character Literal
Character Literal using 
Unicode value Character
' ' '\u0020' Space
'0' '\u0030' 0
'1' '\u0031' 1
'9' '\u0039' 9
'A' '\u0041' A
'B' '\u0042' B
'Z' '\u005a' Z
'a' '\u0061' a
'b' '\u0062' b
Continues
24 CHAPTER 2: LANGUAGE FUNDAMENTALS
Escape Sequences
Certain escape sequences define special characters, as shown in Table 2.7. These
escape sequences can be single-quoted to define character literals. For example, the
character literals '\t' and '\u0009' are equivalent. However, the character literals
'\u000a' and '\u000d' should not be used to represent newline and carriage return
in the source code. These values are interpreted as line-terminator characters by
the compiler, and will cause compile time errors. You should use the escape
sequences '\n' and '\r', respectively, for correct interpretation of these characters
in the source code.
We can also use the escape sequence \ddd to specify a character literal as an octal
value, where each digit d can be any octal digit (0–7), as shown in Table 2.8. The
number of digits must be three or fewer, and the octal value cannot exceed \377,
i.e., only the first 256 characters can be specified with this notation.
'z' '\u007a' z
'Ñ' '\u0084' Ñ
'å' '\u008c' å
'ß' '\u00a7' ß
Table 2.7 Escape Sequences
Escape Sequence Unicode Value Character
\b \u0008 Backspace (BS)
\t \u0009 Horizontal tab (HT or TAB)
\n \u000a Linefeed (LF) a.k.a. Newline (NL)
\f \u000c Form feed (FF)
\r \u000d Carriage return (CR)
\' \u0027 Apostrophe-quote, a.k.a. single quote
\" \u0022 Quotation mark, a.k.a. double quote 
\\ \u005c Backslash
Table 2.6 Examples of Character Literals (Continued)
Character Literal
Character Literal using 
Unicode value Character
2.1: BASIC LANGUAGE ELEMENTS 25
String Literals
A string literal is a sequence of characters which must be enclosed in double quotes
and must occur on a single line. All string literals are objects of the class String (see
Section 10.4, p. 439).
Escape sequences as well as Unicode values can appear in string literals:
In (1), the tab character is specified using the escape sequence and the Unicode
value, respectively. In (2), the single apostrophe need not be escaped in strings, but
it would be if specified as a character literal ('\''). In (3), the double quotes in the
string must be escaped. In (4), we use the escape sequence \n to insert a newline.
(5) generates a compile time error, as the string literal is split over several lines.
Printing the strings from (1) to (4) will give the following result:
Here comes a tab. And here comes another one !
What's on the menu?
"String literals are double-quoted."
Left!
Right!
One should also use the escape sequences \n and \r, respectively, for correct interpretation of the characters \u000a (newline) and \u000d (form feed) in string literals.
White Spaces
A white space is a sequence of spaces, tabs, form feeds, and line terminator characters in a Java source file. Line terminators can be newline, carriage return, or a carriage return-newline sequence.
A Java program is a free-format sequence of characters that is tokenized by the compiler, i.e., broken into a stream of tokens for further analysis. Separators and operators help to distinguish tokens, but sometimes white space has to be inserted
Table 2.8 Examples of Escape Sequence \ddd
Escape Sequence \ddd Character Literal
'\141' 'a'
'\46' '&'
'\60' '0'
"Here comes a tab.\t And here comes another one\u0009!"
"What's on the menu?"
"\"String literals are double-quoted.\""
"Left!\nRight!"
"Don't split
me up!"
(1)
(2)
(3)
(4)
(5)
26 CHAPTER 2: LANGUAGE FUNDAMENTALS
explicitly as a separator. For example, the identifier classRoom will be interpreted as
a single token, unless white space is inserted to distinguish the keyword class from
the identifier Room.
White space aids not only in separating tokens, but also in formatting the program
so that it is easy to read. The compiler ignores the white space
A program can be documented by inserting comments at relevant places in the
source code. These comments are for documentation purposes only and are
ignored by the compiler.
Java provides three types of comments to document a program:
• A single-line comment: // ... to the end of the line
• A multiple-line comment: /* ... */
• A documentation (Javadoc) comment: /** ... */
Single-Line Comment
All characters after the comment-start sequence // through to the end of the line
constitute a single-line comment.
// This comment ends at the end of this line.
int age; // From comment-start sequence to the end of the line is a comment.
Multiple-Line Comment
A multiple-line comment, as the name suggests, can span several lines. Such a comment starts with the sequence /* and ends with the sequence */.
/* A comment
 on several
 lines.
*/
The comment-start sequences (//, /*, /**) are not treated differently from other
characters when occurring within comments, and are thus ignored. This means
that trying to nest multiple-line comments will result in a compile time error:
/* Formula for alchemy.
 gold = wizard.makeGold(stone);
 /* But it only works on Sundays. */
*/
The second occurrence of the comment-start sequence /* is ignored. The last occurrence of the sequence */ in the code is now unmatched, resulting in a syntax error.
REVIEW QUESTIONS 27
Documentation Comment
A documentation comment is a special-purpose comment that is used by the javadoc
tool to generate HTML documentation for the program. Documentation comments
are usually placed in front of classes, interfaces, methods, and field definitions.
Special tags can be used inside a documentation comment to provide more specific
information. Such a comment starts with the sequence /** and ends with the
sequence */:
/**
 * This class implements a gizmo.
 * @author K.A.M.
 * @version 3.0
 */
For details on the javadoc tool, see the tools documentation provided by the JDK.
Review Questions
2.1 Which of the following is not a legal identifier?
Select the one correct answer.
(a) a2z
(b) ödipus
(c) 52pickup
(d) _class
(e) ca$h
2.2 Which statement is true?
Select the one correct answer.
(a) new and delete are keywords in the Java language.
(b) try, catch, and thrown are keywords in the Java language.
(c) static, unsigned, and long are keywords in the Java language.
(d) exit, class, and while are keywords in the Java language.
(e) return, goto, and default are keywords in the Java language.
(f) for, while, and next are keywords in the Java language.
2.3 Which statement about the following comment is true?
/* // */
Select the one correct answer.
(a) The comment is not valid. The multiple-line comment (/* ... */) does not
end correctly, since the comment-end sequence */ is a part of the single-line
comment (// ...).
(b) It is a completely valid comment. The // part is ignored by the compiler.
(c) This combination of comments is illegal, and will result in a compile 
time error.
28 CHAPTER 2: LANGUAGE FUNDAMENTALS
2.2 Primitive Data Types
Figure 2.1 gives an overview of the primitive data types in Java.
Primitive data types in Java can be divided into three main categories:
• integral types—represent signed integers (byte, short, int, long) and unsigned
character values (char)
• floating-point types (float, double)—represent fractional signed numbers
• boolean type (boolean)—represents logical values
Primitive data values are not objects. Each primitive data type defines the range of
values in the data type, and operations on these values are defined by special
operators in the language (see Chapter 5).
Each primitive data type also has a corresponding wrapper class that can be used
to represent a primitive value as an object. Wrapper classes are discussed in Section
10.3, p. 428.
Integer Types
Figure 2.1 Primitive Data Types in Java
Table 2.9 Range of Integer Values
Data Type
Width
(bits)
Minimum value
MIN_VALUE
Maximum value
MAX_VALUE
byte 8 -27
 (-128) 27
-1 (+127)
short 16 -215 (-32768) 215-1 (+32767)
int 32 -231 (-2147483648) 231-1 (+2147483647)
long 64 -263 (-9223372036854775808L) 263-1 (+9223372036854775807L)
Boolean type Numeric types
Integral types Floating-point types
Character type Integer types
boolean char byte short int long float double 
Primitive data types
2.2: PRIMITIVE DATA TYPES 29
Integer data types are byte, short, int, and long (see Table 2.9). Their values are
signed integers represented by 2’s complement (see Section G.4, p. 1010).
The char Type
The data type char represents characters (see Table 2.10). Their values are unsigned
integers that denote all the 65536 (216) characters in the 16-bit Unicode character
set. This set includes letters, digits, and special characters. 
The first 128 characters of the Unicode set are the same as the 128 characters of the
7-bit ASCII character set, and the first 256 characters of the Unicode set correspond
to the 256 characters of the 8-bit ISO Latin-1 character set.
The integer types and the char type are collectively called integral types.
The Floating-Point Types
Floating-point numbers are represented by the float and double data types.
Floating-point numbers conform to the IEEE 754-1985 binary floating-point standard. Table 2.11 shows the range of values for positive floating-point numbers, but
these apply equally to negative floating-point numbers with the '-' sign as a prefix. Zero can be either 0.0 or -0.0.
Since the size for representation is a finite number of bits, certain floating-point
numbers can only be represented as approximations. For example, the value of the
expression (1.0/3.0) is represented as an approximation due to the finite number
of bits used.
Table 2.10 Range of Character Values
Data
Type Width (bits) Minimum Unicode value Maximum Unicode value
char 16 0x0 (\u0000) 0xffff (\uffff)
Table 2.11 Range of Floating-Point Values
Data Type
Width
(bits)
Minimum Positive Value
MIN_VALUE
Maximum Positive Value
MAX_VALUE
float 32 1.401298464324817E-45f 3.402823476638528860e+38f
double 64 4.94065645841246544e-324 1.79769313486231570e+308
30 CHAPTER 2: LANGUAGE FUNDAMENTALS
The boolean Type
The data type boolean represents the two logical values denoted by the literals true
and false (see Table 2.12).
Boolean values are produced by all relational (see Section 5.10, p. 190), conditional
(see Section 5.13, p. 196) and boolean logical operators (see Section 5.12, p. 194), and
are primarily used to govern the flow of control during program execution.
Table 2.13 summarizes the pertinent facts about the primitive data types: their
width or size, which indicates the number of the bits required to store a primitive
value; their range of legal values, which is specified by the minimum and the maximum values permissible; and the name of the corresponding wrapper class (see
Section 10.3, p. 428).
Table 2.12 Boolean Values
Data Type Width True Value Literal False Value Literal
boolean not applicable true false
Table 2.13 Summary of Primitive Data Types
Data Type Width (bits) Minimum Value, Maximum Value Wrapper Class
boolean not applicable true, false Boolean
byte 8 -27, 27-1 Byte
short 16 -215, 215-1 Short
char 16 0x0, 0xffff Character
int 32 -231, 231-1 Integer
long 64 -263, 263-1 Long
float 32 ±1.40129846432481707e-45f,
±3.402823476638528860e+38f
Float
double 64 ±4.94065645841246544e-324,
±1.79769313486231570e+308
Double
2.3: VARIABLE DECLARATIONS 31
Review Questions
2.4 Which of the following do not denote a primitive data value in Java?
Select the two correct answers.
(a) "t"
(b) 'k'
(c) 50.5F
(d) "hello"
(e) false
2.5 Which of the following primitive data types are not integer types?
Select the three correct answers.
(a) boolean
(b) byte
(c) float
(d) short
(e) double
2.6 Which integral type in Java has the exact range from -2147483648 (-231) to
2147483647 (231-1), inclusive?
Select the one correct answer.
(a) byte
(b) short
(c) int
(d) long
(e) char
2.3 Variable Declarations
A variable stores a value of a particular type. A variable has a name, a type, and a
value associated with it. In Java, variables can only store values of primitive data
types and reference values of objects. Variables that store reference values of
objects are called reference variables (or object references or simply references).
Declaring and Initializing Variables
Variable declarations are used to specify the type and the name of variables. This
implicitly determines their memory allocation and the values that can be stored in
them. Examples of declaring variables that can store primitive values:
char a, b, c; // a, b and c are character variables.
double area; // area is a floating-point variable.
boolean flag; // flag is a boolean variable.
32 CHAPTER 2: LANGUAGE FUNDAMENTALS
The first declaration above is equivalent to the following three declarations:
char a;
char b;
char c;
A declaration can also include an initialization expression to specify an appropriate initial value for the variable:
int i = 10, // i is an int variable with initial value 10.
 j = 101; // j is an int variable with initial value 101.
long big = 2147483648L; // big is a long variable with specified initial value.
Reference Variables
An reference variable can store the reference value of an object, and can be used to
manipulate the object denoted by the reference value.
A variable declaration that specifies a reference type (i.e., a class, an array, or an
interface name) declares a reference variable. Analogous to the declaration of variables of primitive data types, the simplest form of reference variable declaration
only specifies the name and the reference type. The declaration determines what
objects can be referenced by a reference variable. Before we can use a reference
variable to manipulate an object, it must be declared and initialized with the reference value of the object.
Pizza yummyPizza; // Variable yummyPizza can reference objects of class Pizza.
Hamburger bigOne, // Variable bigOne can reference objects of class Hamburger,
 smallOne; // and so can variable smallOne.
It is important to note that the declarations above do not create any objects of class
Pizza or Hamburger. The above declarations only create variables that can store references of objects of the specified classes.
A declaration can also include an initializer expression to create an object whose
reference value can be assigned to the reference variable:
Pizza yummyPizza = new Pizza("Hot&Spicy"); // Declaration with initializer.
The reference variable yummyPizza can reference objects of class Pizza. The keyword
new, together with the constructor call Pizza("Hot&Spicy"), creates an object of the
class Pizza. The reference value of this object is assigned to the variable yummyPizza.
The newly created object of class Pizza can now be manipulated through the reference variable yummyPizza.
Initializers for initializing fields in objects, and static variables in classes and interfaces are discussed in Section 9.7, p. 406.
Reference variables for arrays are discussed in Section 3.6, p. 69.
2.4: INITIAL VALUES FOR VARIABLES 33
2.4 Initial Values for Variables
Default Values for Fields
Default values for fields of primitive data types and reference types are listed in
Table 2.14. The value assigned depends on the type of the field.
If no initialization is provided for a static variable either in the declaration or in a
static initializer block (see Section 9.9, p. 410), it is initialized with the default value
of its type when the class is loaded.
Similarly, if no initialization is provided for an instance variable either in the declaration or in an instance initializer block (see Section 9.10, p. 413), it is initialized
with the default value of its type when the class is instantiated.
The fields of reference types are always initialized with the null reference value if
no initialization is provided.
Example 2.1 illustrates default initialization of fields. Note that static variables are
initialized when the class is loaded the first time, and instance variables are initialized accordingly in every object created from the class Light.
Example 2.1 Default Values for Fields
public class Light {
 // Static variable
 static int counter; // Default value 0 when class is loaded.
 // Instance variables:
 int noOfWatts = 100; // Explicitly set to 100.
 boolean indicator; // Implicitly set to default value false.
 String location; // Implicitly set to default value null.
 public static void main(String[] args) {
 Light bulb = new Light();
 System.out.println("Static variable counter: " + Light.counter);
 System.out.println("Instance variable noOfWatts: " + bulb.noOfWatts);
Table 2.14 Default Values
Data Type Default Value
boolean false
char '\u0000'
Integer (byte, short, int, long) 0L for long, 0 for others
Floating-point (float, double) 0.0F or 0.0D
Reference types null
34 CHAPTER 2: LANGUAGE FUNDAMENTALS
 System.out.println("Instance variable indicator: " + bulb.indicator);
 System.out.println("Instance variable location: " + bulb.location);
 return;
 }
}
Output from the program:
Static variable counter: 0
Instance variable noOfWatts: 100
Instance variable indicator: false
Instance variable location: null
Initializing Local Variables of Primitive Data Types
Local variables are variables that are declared in methods, constructors, and blocks
(see Chapter 3, p. 39). Local variables are not initialized when they are created at
method invocation, that is, when the execution of a method is started. The same
applies in constructors and blocks. Local variables must be explicitly initialized
before being used. The compiler will report as errors any attempts to use uninitialized local variables.
Example 2.2 Flagging Uninitialized Local Variables of Primitive Data Types
public class TooSmartClass {
 public static void main(String[] args) {
 int weight = 10, thePrice; // (1) Local variables
 if (weight < 10) thePrice = 1000;
 if (weight > 50) thePrice = 5000;
 if (weight >= 10) thePrice = weight*10; // (2) Always executed.
 System.out.println("The price is: " + thePrice); // (3)
 }
}
In Example 2.2, the compiler complains that the local variable thePrice used in the
println statement at (3) may not be initialized. However, it can be seen that at runtime, the local variable thePrice will get the value 100 in the last if-statement at (2),
before it is used in the println statement. The compiler does not perform a rigorous
analysis of the program in this regard. It only compiles the body of a conditional
statement if it can deduce the condition to be true. The program will compile correctly if the variable is initialized in the declaration, or if an unconditional assignment is made to the variable.
Replacing the declaration of the local variables at (1) in Example 2.2 with the following declaration solves the problem:
int weight = 10, thePrice = 0; // (1') Both local variables initialized.
2.4: INITIAL VALUES FOR VARIABLES 35
Initializing Local Reference Variables
Local reference variables are bound by the same initialization rules as local variables of primitive data types.
Example 2.3 Flagging Uninitialized Local Reference Variables
public class VerySmartClass {
 public static void main(String[] args) {
 String importantMessage; // Local reference variable
 System.out.println("The message length is: " + importantMessage.length());
 }
}
In Example 2.3, the compiler complains that the local variable importantMessage
used in the println statement may not be initialized. If the variable importantMessage is set to the value null, the program will compile. However, a runtime error
(NullPointerException) will occur when the code is executed, since the variable
importantMessage will not denote any object. The golden rule is to ensure that a reference variable, whether local or not, is assigned a reference to an object before it
is used, that is, ensure that it does not have the value null.
The program compiles and runs if we replace the declaration with the following
declaration of the local variable, which creates a string literal and assigns its reference value to the local reference variable importantMessage:
String importantMessage = "Initialize before use!"; 
Arrays and their default values are discussed in Section 3.6, p. 69.
Lifetime of Variables
The lifetime of a variable, that is, the time a variable is accessible during execution,
is determined by the context in which it is declared. The lifetime of a variable is
also called scope, and is discussed in more detail in Section 4.6, p. 129. We distinguish between lifetime of variables in three contexts:
• Instance variables—members of a class, and created for each object of the class.
In other words, every object of the class will have its own copies of these variables, which are local to the object. The values of these variables at any given
time constitute the state of the object. Instance variables exist as long as the
object they belong to is in use at runtime.
• Static variables—also members of a class, but not created for any specific object
of the class and, therefore, belong only to the class (see Section 4.6, p. 129). They
are created when the class is loaded at runtime, and exist as long as the class is
available at runtime.
36 CHAPTER 2: LANGUAGE FUNDAMENTALS
• Local variables (also called method automatic variables)—declared in methods,
constructors, and blocks; and created for each execution of the method, constructor, or block. After the execution of the method, constructor, or block completes, local (non-final) variables are no longer accessible.
Review Questions
2.7 Which declarations are valid?
Select the three correct answers.
(a) char a = '\u0061';
(b) char 'a' = 'a';
(c) char \u0061 = 'a';
(d) ch\u0061r a = 'a';
(e) ch'a'r a = 'a';
2.8 Given the following code within a method, which statement is true?
int a, b;
b = 5;
Select the one correct answer.
(a) Local variable a is not declared.
(b) Local variable b is not declared.
(c) Local variable a is declared but not initialized.
(d) Local variable b is declared but not initialized.
(e) Local variable b is initialized but not declared.
2.9 In which of these variable declarations will the variable remain uninitialized
unless it is explicitly initialized?
Select the one correct answer.
(a) Declaration of an instance variable of type int.
(b) Declaration of a static variable of type float.
(c) Declaration of a local variable of type float.
(d) Declaration of a static variable of type Object.
(e) Declaration of an instance variable of type int[].
2.10 What will be the result of compiling and running the following program?
public class Init {
 String title;
 boolean published;
 static int total;
 static double maxPrice;
PROGRAMMING EXERCISE 37
 public static void main(String[] args) {
 Init initMe = new Init();
 double price;
 if (true)
 price = 100.00;
 System.out.println("|" + initMe.title + "|" + initMe.published + "|" +
 Init.total + "|" + Init.maxPrice + "|" + price+ "|");
 }
}
Select the one correct answer.
(a) The program will fail to compile.
(b) The program will compile, and print |null|false|0|0.0|0.0|, when run.
(c) The program will compile, and print |null|true|0|0.0|100.0|, when run.
(d) The program will compile, and print | |false|0|0.0|0.0|, when run.
(e) The program will compile, and print |null|false|0|0.0|100.0|, when run.
Chapter Summary
The following information was included in this chapter:
• basic language elements: identifiers, keywords, literals, white space, and
comments
• primitive data types: integral, floating-point, and boolean
• notational representation of numbers in decimal, octal, and hexadecimal systems
• declaration and initialization of variables, including reference variables
• usage of default values for instance variables and static variables
• lifetime of instance variables, static variables, and local variables
Programming Exercise
2.1 The following program has several errors. Modify the program so that it will
compile and run without errors.
// Filename: Temperature.java
PUBLIC CLASS temperature {
 PUBLIC void main(string args) {
 double fahrenheit = 62.5;
 */ Convert /*
 double celsius = f2c(fahrenheit);
 System.out.println(fahrenheit + 'F' + " = " + Celsius + 'C');
 }
 double f2c(float fahr) {
 RETURN (fahr - 32) * 5 / 9;
 }
}
This page intentionally left blank 
39
3 Declarations
Exam Objectives
1.3 Develop code that declares, initializes, and uses primitives, arrays, enums, 
and objects as static, instance, and local variables. Also, use legal 
identifiers for variable names.
❍ Enums and arrays are covered in this chapter.
❍ For primitive types, see Section 2.2, p. 28.
❍ For initialization of static, instance, and local variables, see Section 2.3, p. 31.
❍ For initializers, see Section 9.7, p. 406.
1.4 Develop code that declares both static and non-static methods, and—if 
appropriate—use method names that adhere to the JavaBeans naming 
standards. Also develop code that declares and uses a variable-length 
argument list.
1.5 Given a code example, determine if a method is correctly overriding or 
overloading another method, and identify legal return values (including 
covariant returns), for the method.
❍ For overloaded method resolution, see Section 7.10, p. 324.
❍ For overriding methods, see Section 7.2, p. 288.
❍ For return values, see Section 6.4, p. 228.
❍ For covariant return, see Section 7.2, p. 290.
1.6 Given a set of classes and superclasses, develop constructors for one or 
more of the classes. Given a class declaration, determine if a default 
constructor will be created and, if so, determine the behavior of that 
constructor. Given a nested or non-nested class listing, write code to 
instantiate the class.
❍ For constructor chaining, see Section 7.5, p. 302, and Section 9.11, p. 416.
❍ For instantiating nested classes, see Chapter 8.
7.2 Given an example of a class and a command-line, determine the expected 
runtime behavior.
7.3 Determine the effect upon object references and primitive values when 
they are passed into methods that perform assignments or other 
modifying operations on the parameters
A class declaration introduces a new reference type. It has the following general
syntax:
<class modifiers> class <class name><formal type parameter list>
<extends clause> <implements clause> // Class header
{ // Class body
<field declarations>
<method declarations>
<nested class declarations>
<nested interface declarations>
<nested enum declarations>
<constructor declarations>
<initializer blocks>
}
In the class header, the name of the class is preceded by the keyword class. In
addition, the class header can specify the following information:
• accessibility modifier (see Section 4.7, p. 132)
• additional class modifiers (see Section 4.8, p. 135)
• a formal type parameter list, if the class is generic (see Section 14.2, p. 663)
• any class it extends (see Section 7.1, p. 284)
• any interfaces it implements (see Section 7.6, p. 309)
The class body can contain member declarations which comprise:
• field declarations (see Section 2.3, p. 31)
• method declarations (see Section 3.3, p. 44)
• nested class, enum, and interface declarations (see Section 8.1, p. 352)
Members declared static belong to the class and are called static members. Nonstatic members belong to the objects of the class and are called instance members. In
addition, the following can be declared in a class body:
• constructor declarations (see Section 3.4, p. 48)
• static and instance initializer blocks (see Section 9.7, p. 406)
The member declarations, constructor declarations, and initializer blocks can
appear in any order in the class body.
In order to understand what code can be legally declared in a class, we distinguish
between static context and non-static context. A static context is defined by static
methods, static field initializers, and static initializer blocks. A non-static context
is defined by instance methods, constructors, non-static field initializers, and
instance initializer blocks. By static code we mean expressions and statements in a
static context, and similarly by non-static code we mean expressions and statements
3.2: JAVABEANS STANDARD 41
in a non-static context. One crucial difference between the two contexts is that
static code can only refer to other static members.
3.2 JavaBeans Standard
The JavaBeans Standard allows reusable software components to be modelled in
Java so that these components can be assembled to create sophisticated applications. In particular, builder tools can take advantage of how these components are
specified, in order to build new applications based on these components. The JavaBeans specification specifies the rules for defining such components (called JavaBeans). The interested reader is encouraged to consult this documentation (see
http://java.sun.com/javase/technologies/desktop/javabeans/docs/spec.html) for
details since we only cover the basic fundamentals for creating JavaBeans .
Naming Patterns for Properties
The rules of the JavaBean specification stipulate naming patterns for declaring properties of JavaBeans. A naming pattern defines a standard naming convention. A
property of an object is normally defined as a field in the object, which is usually
not directly accessible by clients (see Example 3.1). A JavaBean should adhere to
the following naming patterns when specifying its properties:
• The properties are assumed to be private, and their names start with a lowercase letter. Example 3.1 shows that the JavaBean class Light has three properties.
• In order to retrieve and change values of its properties, a JavaBean provides
getter and setter methods for them. Example 3.1 shows a JavaBean with three
getter and three setter methods for its properties.
• For a property, the setter method starts with the prefix set. The rest of the
method name is assumed to be a property name, where the first letter of the
property name has been converted to uppercase. In Example 3.1, the value of
the property noOfWatts can be changed by the setter method setNoOfWatts().
Setter methods are public and void, having a parameter of the same type as that
of the property.
• For a property, the getter method starts with the prefix get. The rest of the
method name is assumed to be a property name, where the first letter of the
property name has been converted to uppercase. In Example 3.1, the value of
the property noOfWatts can be retrieved by the getter method getNoOfWatts().
For a boolean property, the getter method can start with the prefix get or is. In
Example 3.1, the value of the boolean property indicator can be retrieved by the
getter method isIndicator().
Getter methods are no-argument public methods that return a value of the
same type as the parameter of the corresponding setter method.
42 CHAPTER 3: DECLARATIONS
Example 3.1 A JavaBean
public class Light {
 // Properties:
 private int noOfWatts; // wattage
 private String location; // placement
 private boolean indicator; // on or off
 // Setters
 public void setNoOfWatts(int noOfWatts) { this.noOfWatts = noOfWatts; }
 public void setLocation(String location) { this.location = location; }
 public void setIndicator(boolean indicator) { this.indicator = indicator; }
 // Getters
 public int getNoOfWatts() { return noOfWatts; }
 public String getLocation() { return location; }
 public boolean isIndicator() { return indicator; }
}
Naming Patterns for the Event Model
A listener is an object that is interested in being notified when a particular event
takes place. The origin of this event is usually an object called the source, which
notifies interested listeners when the event occurs. In this setup, a listener can be
added to or removed from the list of listeners notified by a source about the occurrence of a particular event. This setup is the basis of the event model which is
depicted in Figure 3.1. 
The JavaBean specification stipulates naming patterns for the event model to facilitate its use by builder tools to assemble event-based applications. Figure 3.1 shows
where the naming patterns for handling events of type X are applied:
• An event class with the name XEvent, that extends the java.util.EventObject
class.
public class XEvent extends java.util.EventObject {
 public XEvent(Object source) {
 super(source);
 }
}
• A listener interface with the name XListener, that specifies the specific method
to be called in a listener when an event of the type XEvent occurs. The listener
interface extends the java.util.EventListener interface. 
public interface XListener extends java.util.EventListener {
 public void methodAInXListener(XEvent ev);
}
A listener interested in XEvents must implement the XListener interface, and
must be registered with the source in order to be informed about XEvents.
3.2: JAVABEANS STANDARD 43
public class ListenerObject implements XListener {
 public void methodAInXListener(XEvent e) { /* ... */ }
}
• A source for XEvent, that implements the methods addXListener() and removeXListener(). These methods are used to add or remove a listener interested in
XEvents, respectively. The parameter of these methods is of the type XListener.
public class SourceObject {
 public synchronized void addXListener(XListener listener) { /* ... */ }
 public synchronized void removeXListener(XListener listener) { /* ... */ }
}
Note that there are no naming patterns defined for the names of the source and the
listener classes. Neither is there any standard convention for naming the methods
specified in the listener interface.
Figure 3.1 The Event Model
event X
A listener interested in XEvent events is registered with the source using the addXListener() method.
The listener must implement the XListener interface in order to recieve events of type XEvent.
The listener is informed about events of type XEvent via the methodAInXListener()
in the XListener interface.
listener
methodAInXListener(XEvent e)

In addition to the name of the method, the method header can specify the following information:
• scope or accessibility modifier (see Section 4.9, p. 138)
• additional method modifiers (see Section 4.10, p. 146)
• a formal type parameter list, if the declaration is for a generic method (see Section
14.8, p. 697)
• the type of the return value, or void if the method does not return any value (see
Section 6.4, p. 228)
• a formal parameter list (see below)
• checked exceptions thrown by the method are specified in a throws clause (see
Section 6.9, p. 257)parameters for passing information to the method when the method is invoked by a method call (see Section 3.7,
The formal parameter list is a comma-separated list of parameters for passing information to the method when the method is invoked by a method call (see Section 3.7,
p. 81). An empty parameter list must be specified by ( ). Each parameter is a simple
variable declaration consisting of its type and name:
<parameter modifier> <type> <parameter name>
The parameter names are local to the method (see Section 4.6, p. 131). The parameter modifier final is discussed in Section 3.7 on page 89.
The signature of a method comprises the method name and the formal parameter
list only.sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram 
sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram sitaram
The method body is a block containing the local declarations and the statements of the
method. Local variable declarations are discussed in Section 2.3 on page 31, and
nested local class declarations in Section 8.4 on page 371.
Like member variables, member methods can be characterized as:
• instance methods
• static methods, which are discussed in Section 4.10, p. 148.
3.3: METHOD DECLARATIONS 45
Statements
Statements in Java can be grouped into various categories. Variable declarations
with explicit initialization of the variables are called declaration statements (see Section 2.3, p. 31, and Section 3.6, p. 71). Other basic forms of statements are control
flow statements (see Section 6.1, p. 204) and expression statements.
An expression statement is an expression terminated by a semicolon. The expression
is evaluated for its side effect and its value discarded. Only certain types of expressions have meaning as statements. They include the following:
• assignments (see Section 5.5, p. 169)
• increment and decrement operators (see Section 5.8, p. 186)
• method calls (see Section 3.7, p. 81)
• object creation expressions with the new operator (see Section 5.15, p. 201)
A solitary semicolon denotes the empty statement that does nothing.
A block, {}, is a compound statement which can be used to group zero or more local
declarations and statements (see Section 4.6, p. 131). Blocks can be nested, since a
block is a statement that can contain other statements. A block can be used in any
context where a simple statement is permitted. The compound statement which is
embodied in a block, begins at the left brace, {, and ends with a matching right
brace, }. Such a block must not be confused with an array initialization block in
declaration statements (see Section 3.6, p. 71). 
Labeled statements are discussed in Section 6.4 on page 223.
Instance Methods and the Object Reference this
Instance methods belong to every object of the class and can only be invoked on
objects. All members defined in the class, both static and non-static, are accessible
in the context of an instance method. The reason is that all instance methods are
passed an implicit reference to the current object, that is, the object on which the
method is being invoked. The current object can be referenced in the body of the
instance method by the keyword this. In the body of the method, the this reference
can be used like any other object reference to access members of the object. In fact,
the keyword this can be used in any non-static context. The this reference can be
used as a normal reference to reference the current object, but the reference cannot
be modified—it is a final reference (Section 4.10, p. 148).
The this reference to the current object is useful in situations where a local variable
hides, or shadows, a field with the same name. In Example 3.2, the two parameters
noOfWatts and indicator in the constructor of the Light class have the same names
as the fields in the class. The example also declares a local variable location, which
has the same name as one of the fields. The reference this can be used to distinguish the fields from the local variables. At (1), the this reference is used to identify
the field noOfWatts, which is assigned the value of the parameter noOfWatts.kkkkkkk
hhhhhhhh
yyyyyyyyy
PPPPPPP
PPPPPPPPPP